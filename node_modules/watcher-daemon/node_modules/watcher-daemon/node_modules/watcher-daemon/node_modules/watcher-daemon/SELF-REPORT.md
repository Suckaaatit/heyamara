# Watcher Daemon - Self Report

## 1. Implementation Summary

This daemon is a **deterministic file-watcher system** with an **LLM-powered rule compiler at the edge**.
The LLM is used **only** to compile natural-language rules into structured JSON. After that, rule evaluation is purely deterministic.

Core subsystems:
- **Watcher**: chokidar-based, debounced, emits normalized events (`created`, `modified`, `deleted`).
- **Rule Compiler (LLM once)**: converts natural language to a structured rule.
- **Rule Engine (deterministic)**: evaluates events against stored rules, including time-windowed thresholds.
- **Rule Store**: JSON persistence with restart safety.
- **Notifier**: console + OS notifications.
- **API**: localhost-only endpoints for rules, compile preview, matches, health, report.

## 2. What Works

| Feature | Status | Notes |
|---|---|---|
| File watching | ‚úÖ Working | Recursive watch with debounce |
| Normalized events | ‚úÖ Working | `created/modified/deleted` |
| Rule compilation | ‚úÖ Working | LLM used only on rule creation |
| Deterministic evaluation | ‚úÖ Working | No LLM in evaluation |
| Count-based rules | ‚úÖ Working | `threshold` rules with window + count |
| Pattern rules | ‚úÖ Working | pathIncludes/extensions/eventTypes |
| Rule persistence | ‚úÖ Working | JSON file in `data/rules.db` |
| Notifications | ‚úÖ Working | Console + OS |
| Logging | ‚úÖ Working | Structured winston logs |
| Local API | ‚úÖ Working | /health, /rules, /matches, /report |
| Compile preview | ‚úÖ Working | /rules/compile |
| Rule validation | ‚úÖ Working | Rejects broad or unsafe rules |

## 3. What Breaks / Limitations

| Issue | Severity | Description |
|---|---|---|
| JSON store concurrency | üü° Medium | No file-locking if multiple processes write |
| Match history | üü° Medium | Recent matches are in-memory only |
| Threshold windows | üü° Medium | In-memory counters reset on restart |
| LLM availability | üü¢ Low | Rule creation fails if Ollama is down |
| Rule expressiveness | üü¢ Low | Only pattern + threshold rules (by design) |

## 3.1 Expected Tradeoffs (Intentional)

- JSON vs. SQLite: Chosen for simplicity and zero dependencies. Atomic writes are used to prevent corruption.
- In-memory history: Match history is kept in-memory for `/matches` to avoid disk I/O. History resets on restart, which is acceptable for this monitoring use case.
- Single watch root: Simplifies configuration and aligns with the requirement to ‚Äúmonitor a directory.‚Äù
- No clustering: Explicitly out of scope for this challenge.

## 4. Token Usage & Cost

LLM usage occurs **only on rule creation**.

- Each rule compile: ~200‚Äì800 tokens (prompt + response)
- Local Ollama cost: $0
- Remote LLM (if swapped): low single-digit cents per rule

Token usage is tracked in `LLMClient` and surfaced in `/report`.

## 5. Logging & Reporting

Logs (JSON via winston):
- File events observed
- Rule evaluations
- Rule matches
- Errors/failures

`GET /report` returns:
- LLM token usage
- Rule counts + top matches
- Engine stats (events observed, rules evaluated, matches)

`GET /matches` returns recent matches (in-memory ring buffer).
Each match includes a human-readable `reason`.

## 6. Tests Run

```bash
npm run build
npm test
```

## 7. Security & Safety

- Watch directory validation prevents system paths.
- Path validation for events (allowed bases, blocked extensions).
- Rule validation prevents overly broad rules.
- API binds to `127.0.0.1` only (localhost).

## 8. Recommended Next Steps (Optional)

1. Persist match history to disk.
2. Add rule update endpoint with recompilation.
3. Add Prometheus-compatible metrics export.

---

**Generated:** 2026-02-08  
**Spec Alignment:** Deterministic core with LLM compiler at the edge
