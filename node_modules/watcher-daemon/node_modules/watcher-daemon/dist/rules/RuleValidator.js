"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateCompiledRule = validateCompiledRule;
const MIN_WINDOW_SECONDS = 10;
const MAX_WINDOW_SECONDS = 86400;
const MIN_THRESHOLD_COUNT = 1;
const MAX_THRESHOLD_COUNT = 1000;
function validateCompiledRule(rule) {
    const errors = [];
    if (!rule.type) {
        errors.push({ field: 'type', message: 'Rule type is required' });
    }
    const matchErrors = validateMatchFilter(rule.match);
    errors.push(...matchErrors);
    if (rule.type === 'threshold') {
        if (typeof rule.windowSeconds !== 'number' || Number.isNaN(rule.windowSeconds)) {
            errors.push({ field: 'windowSeconds', message: 'windowSeconds must be a number' });
        }
        else if (rule.windowSeconds < MIN_WINDOW_SECONDS || rule.windowSeconds > MAX_WINDOW_SECONDS) {
            errors.push({
                field: 'windowSeconds',
                message: `windowSeconds must be between ${MIN_WINDOW_SECONDS} and ${MAX_WINDOW_SECONDS}`,
            });
        }
        if (typeof rule.count !== 'number' || Number.isNaN(rule.count)) {
            errors.push({ field: 'count', message: 'count must be a number' });
        }
        else if (rule.count < MIN_THRESHOLD_COUNT || rule.count > MAX_THRESHOLD_COUNT) {
            errors.push({
                field: 'count',
                message: `count must be between ${MIN_THRESHOLD_COUNT} and ${MAX_THRESHOLD_COUNT}`,
            });
        }
    }
    // Prevent overly broad rules
    const hasPathOrExtension = (rule.match.pathIncludes && rule.match.pathIncludes.length > 0) ||
        (rule.match.extensions && rule.match.extensions.length > 0);
    if (!hasPathOrExtension) {
        errors.push({
            field: 'match',
            message: 'Rule is too broad. Add pathIncludes or extensions to narrow scope.',
        });
    }
    return { valid: errors.length === 0, errors };
}
function validateMatchFilter(match) {
    const errors = [];
    if (!match || typeof match !== 'object') {
        errors.push({ field: 'match', message: 'match filter is required' });
        return errors;
    }
    const validateArray = (field) => {
        const value = match[field];
        if (value !== undefined && (!Array.isArray(value) || value.some((v) => typeof v !== 'string'))) {
            errors.push({ field: String(field), message: `${String(field)} must be an array of strings` });
        }
    };
    validateArray('pathIncludes');
    validateArray('pathExcludes');
    validateArray('extensions');
    validateArray('eventTypes');
    if (match.extensions) {
        for (const ext of match.extensions) {
            if (!ext.startsWith('.')) {
                errors.push({ field: 'extensions', message: `Extension "${ext}" must start with "."` });
            }
        }
    }
    if (match.eventTypes) {
        const allowed = ['created', 'modified', 'deleted'];
        for (const eventType of match.eventTypes) {
            if (!allowed.includes(eventType)) {
                errors.push({ field: 'eventTypes', message: `Invalid event type "${eventType}"` });
            }
        }
    }
    return errors;
}
//# sourceMappingURL=RuleValidator.js.map