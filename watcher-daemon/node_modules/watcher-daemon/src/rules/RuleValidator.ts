import { CompiledRule } from '../llm/types';
import { EventType, MatchFilter } from './types';

export interface ValidationError {
  field: string;
  message: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
}

const MIN_WINDOW_SECONDS = 10;
const MAX_WINDOW_SECONDS = 86400;
const MIN_THRESHOLD_COUNT = 1;
const MAX_THRESHOLD_COUNT = 1000;

export function validateCompiledRule(rule: CompiledRule): ValidationResult {
  const errors: ValidationError[] = [];

  if (!rule.type) {
    errors.push({ field: 'type', message: 'Rule type is required' });
  }

  const matchErrors = validateMatchFilter(rule.match);
  errors.push(...matchErrors);

  if (rule.type === 'threshold') {
    if (typeof rule.windowSeconds !== 'number' || Number.isNaN(rule.windowSeconds)) {
      errors.push({ field: 'windowSeconds', message: 'windowSeconds must be a number' });
    } else if (rule.windowSeconds < MIN_WINDOW_SECONDS || rule.windowSeconds > MAX_WINDOW_SECONDS) {
      errors.push({
        field: 'windowSeconds',
        message: `windowSeconds must be between ${MIN_WINDOW_SECONDS} and ${MAX_WINDOW_SECONDS}`,
      });
    }

    if (typeof rule.count !== 'number' || Number.isNaN(rule.count)) {
      errors.push({ field: 'count', message: 'count must be a number' });
    } else if (rule.count < MIN_THRESHOLD_COUNT || rule.count > MAX_THRESHOLD_COUNT) {
      errors.push({
        field: 'count',
        message: `count must be between ${MIN_THRESHOLD_COUNT} and ${MAX_THRESHOLD_COUNT}`,
      });
    }
  }

  // Prevent overly broad rules
  const hasPathOrExtension =
    (rule.match.pathIncludes && rule.match.pathIncludes.length > 0) ||
    (rule.match.extensions && rule.match.extensions.length > 0);
  if (!hasPathOrExtension) {
    errors.push({
      field: 'match',
      message: 'Rule is too broad. Add pathIncludes or extensions to narrow scope.',
    });
  }

  return { valid: errors.length === 0, errors };
}

function validateMatchFilter(match: MatchFilter): ValidationError[] {
  const errors: ValidationError[] = [];

  if (!match || typeof match !== 'object') {
    errors.push({ field: 'match', message: 'match filter is required' });
    return errors;
  }

  const validateArray = (field: keyof MatchFilter) => {
    const value = match[field];
    if (value !== undefined && (!Array.isArray(value) || value.some((v) => typeof v !== 'string'))) {
      errors.push({ field: String(field), message: `${String(field)} must be an array of strings` });
    }
  };

  validateArray('pathIncludes');
  validateArray('pathExcludes');
  validateArray('extensions');
  validateArray('eventTypes');

  if (match.extensions) {
    for (const ext of match.extensions) {
      if (!ext.startsWith('.')) {
        errors.push({ field: 'extensions', message: `Extension "${ext}" must start with "."` });
      }
    }
  }

  if (match.eventTypes) {
    const allowed: EventType[] = ['created', 'modified', 'deleted'];
    for (const eventType of match.eventTypes) {
      if (!allowed.includes(eventType)) {
        errors.push({ field: 'eventTypes', message: `Invalid event type "${eventType}"` });
      }
    }
  }

  return errors;
}
